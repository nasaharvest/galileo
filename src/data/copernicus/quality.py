"""Quality control utilities for Copernicus satellite data.

This module provides functions for quality assessment and masking of satellite imagery,
particularly cloud masking for Sentinel-2 optical data.
"""

import tempfile
import zipfile
from pathlib import Path
from typing import Optional

import numpy as np
import rasterio


def extract_cloud_mask(zip_file_path: Path) -> Optional[np.ndarray]:
    """Extract cloud mask from Sentinel-2 Scene Classification Layer (SCL).

    WHAT IS THE SCL BAND:
    The Scene Classification Layer (SCL) is a quality band included with Sentinel-2
    Level-2A products. It classifies each pixel into categories like cloud, shadow,
    vegetation, water, etc. This is generated by the Sen2Cor atmospheric correction
    algorithm.

    WHY CLOUD MASKING MATTERS:
    Clouds obscure the ground and make optical imagery unusable for analysis.
    Cloud masking allows you to:
    - Identify which pixels contain valid ground observations
    - Exclude cloudy pixels from analysis
    - Find the clearest images in a time series
    - Create cloud-free composites by combining multiple images

    SCL CLASSIFICATION VALUES:
    The SCL band uses integer values to classify each pixel:
    - 0 = No Data (missing or invalid)
    - 1 = Saturated or defective pixel
    - 2 = Dark area (very low reflectance, topographic shadow)
    - 3 = Cloud shadow
    - 4 = Vegetation (CLEAR - keep this)
    - 5 = Not vegetated (bare soil, rock) (CLEAR - keep this)
    - 6 = Water (CLEAR - keep this)
    - 7 = Unclassified
    - 8 = Cloud medium probability (MASK OUT)
    - 9 = Cloud high probability (MASK OUT)
    - 10 = Thin cirrus (high altitude ice clouds) (MASK OUT)
    - 11 = Snow or ice (usually MASK OUT, depends on application)

    MASKING STRATEGY:
    We create a binary mask where:
    - 1 (True) = Clear pixel, safe to use (classes 4, 5, 6)
    - 0 (False) = Problematic pixel, should be masked (clouds, shadows, etc.)

    Args:
        zip_file_path: Path to Sentinel-2 Level-2A ZIP file
                      Note: Level-1C products don't have SCL band!
                      Example: S2A_MSIL2A_20220101T123456_..._.zip

    Returns:
        Binary mask array where:
        - 1 = Clear pixel (vegetation, bare soil, water)
        - 0 = Masked pixel (cloud, shadow, snow, etc.)
        Shape: (height, width) matching the 20m resolution bands
        Returns None if extraction fails or SCL band not found

    Example:
        >>> mask = extract_cloud_mask(s2_l2a_file)
        >>> print(f"Clear pixels: {mask.sum() / mask.size * 100:.1f}%")
        >>> # Apply mask to RGB image
        >>> rgb_masked = rgb_image.copy()
        >>> rgb_masked[mask == 0] = 0  # Set cloudy pixels to black
    """
    try:
        with tempfile.TemporaryDirectory() as temp_dir:
            temp_path = Path(temp_dir)

            # Extract ZIP file
            with zipfile.ZipFile(zip_file_path, "r") as zip_ref:
                zip_ref.extractall(temp_path)

            # Find SAFE directory
            safe_dirs = list(temp_path.glob("*.SAFE"))
            if not safe_dirs:
                print(f"No SAFE directory found in {zip_file_path.name}")
                return None

            safe_dir = safe_dirs[0]

            # Check if this is a Level-2A product (has SCL band)
            # Level-1C products don't have SCL
            if "MSIL1C" in safe_dir.name:
                print(
                    f"Warning: {zip_file_path.name} is Level-1C (no SCL band). "
                    "Cloud masking requires Level-2A products."
                )
                return None

            # Find IMG_DATA directory
            img_data_dir = safe_dir / "GRANULE"
            granule_dirs = list(img_data_dir.glob("*"))

            if not granule_dirs:
                print(f"No granule directories found in {zip_file_path.name}")
                return None

            granule_dir = granule_dirs[0]

            # SCL band is in IMG_DATA/R20m/ subdirectory (20m resolution)
            img_dir_20m = granule_dir / "IMG_DATA" / "R20m"
            if not img_dir_20m.exists():
                # Try alternative structure (older products)
                img_dir_20m = granule_dir / "IMG_DATA"

            # Find SCL band file
            # Naming pattern: T31UGQ_20220101T123456_SCL_20m.jp2
            scl_patterns = [
                "*_SCL_20m.jp2",  # Standard pattern
                "*_SCL.jp2",  # Alternative pattern
                "*SCL*.jp2",  # Fallback pattern
            ]

            scl_file = None
            for pattern in scl_patterns:
                scl_matches = list(img_dir_20m.glob(pattern))
                if scl_matches:
                    scl_file = scl_matches[0]
                    break

            if scl_file is None:
                print(f"SCL band not found in {zip_file_path.name}")
                print(f"Available files: {list(img_dir_20m.glob('*.jp2'))}")
                return None

            # Read SCL band
            with rasterio.open(scl_file) as src:
                scl_data = src.read(1)  # Read first (and only) band

            # Create binary mask based on SCL classification
            # Clear pixels: vegetation (4), not vegetated (5), water (6)
            # These are the classes where we can see the ground clearly
            clear_classes = [4, 5, 6]

            # Initialize mask as all zeros (all masked)
            mask = np.zeros_like(scl_data, dtype=np.uint8)

            # Set clear pixels to 1
            for clear_class in clear_classes:
                mask[scl_data == clear_class] = 1

            # Calculate cloud coverage statistics for user feedback
            total_pixels = mask.size
            clear_pixels = mask.sum()
            cloud_coverage = (1 - clear_pixels / total_pixels) * 100

            print(f"Cloud coverage: {cloud_coverage:.1f}% (based on SCL classification)")

            return mask

    except Exception as e:
        print(f"Error extracting cloud mask from {zip_file_path.name}: {e}")
        import traceback

        traceback.print_exc()
        return None


def apply_cloud_mask_to_image(
    image_array: np.ndarray, cloud_mask: np.ndarray, fill_value: float = 0.0
) -> np.ndarray:
    """Apply cloud mask to an image array.

    This function sets cloudy pixels to a fill value (typically 0 or NaN).

    Args:
        image_array: Image array to mask, shape (H, W) or (H, W, C)
        cloud_mask: Binary mask where 1=clear, 0=cloudy, shape (H, W)
        fill_value: Value to use for masked pixels (0.0 for black, np.nan for NaN)

    Returns:
        Masked image array with same shape as input

    Example:
        >>> rgb_masked = apply_cloud_mask_to_image(rgb_array, cloud_mask, fill_value=0.0)
        >>> # Or use NaN for numerical analysis
        >>> rgb_masked = apply_cloud_mask_to_image(rgb_array, cloud_mask, fill_value=np.nan)
    """
    # Create a copy to avoid modifying original
    masked_image = image_array.copy()

    # Handle different array dimensions
    if image_array.ndim == 2:
        # Single band image (H, W)
        masked_image[cloud_mask == 0] = fill_value
    elif image_array.ndim == 3:
        # Multi-band image (H, W, C)
        # Broadcast mask across all channels
        masked_image[cloud_mask == 0, :] = fill_value
    else:
        raise ValueError(f"Unsupported image dimensions: {image_array.ndim}")

    return masked_image
